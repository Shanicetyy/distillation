

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. Amundson_1958 &mdash; distillation 0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="5. Bubble Point" href="bubble.html" />
    <link rel="prev" title="3. Material and Energy Balances" href="balances.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> distillation
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="about.html">1. About</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="balances.html">3. Material and Energy Balances</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Amundson_1958</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#mathematical-trick">4.1. Mathematical Trick</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-algorithm">4.2. The algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorial">4.3. Tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#step-1-input">4.3.1. Step 1, Input</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-2-make-initial-guess">4.3.2. Step 2, Make Initial Guess</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-3-update-k-values">4.3.3. Step 3, Update <span class="math notranslate nohighlight">\(K\)</span>-values</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-4-solve-component-mass-balances">4.3.4. Step 4, Solve Component Mass Balances</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-5">4.3.5. Step 5</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-6-t-j-convergence-check">4.3.6. Step 6, <span class="math notranslate nohighlight">\(T_j\)</span> Convergence Check</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-7-solve-energy-balances">4.3.7. Step 7, Solve Energy Balances</a></li>
<li class="toctree-l3"><a class="reference internal" href="#step-8-v-j-l-j-convergence-check">4.3.8. Step 8, <span class="math notranslate nohighlight">\(V_j\)</span>, <span class="math notranslate nohighlight">\(L_j\)</span> Convergence Check</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#putting-it-all-together">4.4. Putting it all together</a></li>
<li class="toctree-l2"><a class="reference internal" href="#class-method-reference">4.5. Class Method Reference</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="bubble.html">5. Bubble Point</a></li>
<li class="toctree-l1"><a class="reference internal" href="equil.html">6. Equilibrium Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">7. modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">distillation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li><span class="section-number">4. </span>Amundson_1958</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/amundson.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="amundson-1958">
<h1><span class="section-number">4. </span>Amundson_1958<a class="headerlink" href="#amundson-1958" title="Permalink to this headline">¶</a></h1>
<p>This code follows the approach that was published by Amundson and Pontinen <a class="reference internal" href="#amundson1958" id="id1"><span>[Amundson1958]</span></a>.</p>
<dl class="citation">
<dt class="label" id="amundson1958"><span class="brackets"><a class="fn-backref" href="#id1">Amundson1958</a></span></dt>
<dd><p>Amundson, NR and Pontinen, AJ. Multicomponent Distillation Calculations on a Large Digital Computer. <em>Ind. Eng. Chem.</em> 1958;50:730–736.</p>
</dd>
</dl>
<p>This approach takes advantage of the following mathematical trick.</p>
<div class="section" id="mathematical-trick">
<span id="tri-matrix"></span><h2><span class="section-number">4.1. </span>Mathematical Trick<a class="headerlink" href="#mathematical-trick" title="Permalink to this headline">¶</a></h2>
<p>A system of equations such as</p>
<div class="math notranslate nohighlight">
\[Ax=b\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is a matrix of constants,
<span class="math notranslate nohighlight">\(x\)</span> is a vector of unknowns,
and <span class="math notranslate nohighlight">\(b\)</span> is a vector of constants,
can be solved very efficiently if the matrix
<span class="math notranslate nohighlight">\(A\)</span> can be made into the following form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A = \begin{bmatrix}
    d_0 &amp; u_0 &amp; 0 &amp; 0 &amp; 0  \\
    l_0 &amp; d_1 &amp; u_1 &amp; 0 &amp; 0 \\
    0 &amp; l_1 &amp; d_2 &amp; u_2 &amp; 0  \\
    0 &amp; 0 &amp; l_2 &amp; d_3 &amp; u_3  \\
    0 &amp; 0 &amp;  0 &amp; l_3 &amp; d_4
\end{bmatrix}\end{split}\]</div>
<p>This special type of matrix
is called a <a class="reference external" href="https://en.wikipedia.org/wiki/Tridiagonal_matrix">tridiagonal_matrix</a>.</p>
<p>It can be solved, for example, if we define the following vectors</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    l &amp;= [l_0, l_1, l_2, l_3] \\
    d &amp;= [d_0, d_1, d_2, d_3, d_4] \\
    u &amp;= [u_0, u_1, u_2, u_3] \\
    b &amp;= [b_0, b_1, b_2, b_3]
\end{align}\end{split}\]</div>
<p>or, with python code, like</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="n">l_0</span><span class="p">,</span> <span class="n">l_1</span><span class="p">,</span> <span class="n">l_2</span><span class="p">,</span> <span class="n">l_3</span><span class="p">]</span>
<span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_0</span><span class="p">,</span> <span class="n">d_1</span><span class="p">,</span> <span class="n">d_2</span><span class="p">,</span> <span class="n">d_3</span><span class="p">,</span> <span class="n">d_4</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">u_0</span><span class="p">,</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u_2</span><span class="p">,</span> <span class="n">u_3</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">b_0</span><span class="p">,</span> <span class="n">b_1</span><span class="p">,</span> <span class="n">b_2</span><span class="p">,</span> <span class="n">b_3</span><span class="p">]</span>
</pre></div>
</div>
<p>the <span class="math notranslate nohighlight">\(5\times5\)</span> matrix can be solved
efficiently using the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">linalg</span><span class="p">,</span> <span class="n">diags</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">diags</span><span class="p">(</span>
    <span class="n">diagonals</span><span class="o">=</span><span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">u</span><span class="p">],</span>
    <span class="n">offsets</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
    <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">linalg</span><span class="o">.</span><span class="n">spsolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>This mathematical trick is used throughout
the solution algorithm.</p>
</div>
<div class="section" id="the-algorithm">
<h2><span class="section-number">4.2. </span>The algorithm<a class="headerlink" href="#the-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The complete algorithm is shown in the diagram below.</p>
<div class="graphviz"><img src="_images/graphviz-97d9c31bef3ff69b982f778b74958580c6feda85.png" alt="digraph {
    input -&gt; initial_guess -&gt; calc_K -&gt; mass_balance -&gt; bubble_pt -&gt; converg_1;
    converg_1 -&gt; calc_K[label=&quot;No&quot;,color=red];
    converg_1 -&gt; energy_balance[label=&quot;Yes&quot;,color=green];
    energy_balance -&gt; converg_2;
    converg_2 -&gt; finish[label=&quot;Yes&quot;,color=green];
    converg_2 -&gt; mass_balance[label=&quot;No&quot;,color=red];

    input [shape=polygon,side=4,label=&quot;1. Input equilibrium and enthalpy data.\n Input design variables&quot;];
    initial_guess [shape=polygon,side=4,label=&quot;2. Pick L, V, T\n on every stage&quot;];
    calc_K [shape=polygon,side=4,label=&quot;3. Calculate K for each component\n on each stage&quot;];
    mass_balance [shape=polygon,side=4,label=&quot;4. Solve component mass\n balances in matrix form&quot;,color=lightblue,style=filled];
    bubble_pt [shape=polygon,side=4,label=&quot;5. Calculate T on each stage\n using bubble point calculation&quot;];
    converg_1 [shape=diamond,label=&quot;6. Determine whether\n T is converged\n for all stages&quot;];
    energy_balance [shape=polygon,side=4,label=&quot;7. Use energy balance to calculate\n L, V on every stage&quot;,color=lightblue,style=filled];
    converg_2 [shape=diamond,label=&quot;8. Determine whether\n L, V are converged\n for all stages&quot;];
    finish [shape=ellipse,label=&quot;9. Finished&quot;];
}" class="graphviz" /></div>
</div>
<div class="section" id="tutorial">
<h2><span class="section-number">4.3. </span>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h2>
<div class="section" id="step-1-input">
<h3><span class="section-number">4.3.1. </span>Step 1, Input<a class="headerlink" href="#step-1-input" title="Permalink to this headline">¶</a></h3>
<p>In Step 1, the property data and design variables are input.
The property data is described in <a class="reference internal" href="equil.html#equil-data"><span class="std std-ref">Equilibrium Properties</span></a>.
A model with this property data and input design variables is created
by the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">distillation.amundson_1958</span> <span class="kn">import</span> <span class="n">Model</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
<span class="go">        components=[&#39;n-Butane&#39;, &#39;n-Pentane&#39;],</span>
<span class="go">        F=1000.,              # feed flow rate [kmol/h]</span>
<span class="go">        P=101325.*2,          # pressure (constant) [Pa]</span>
<span class="go">        z_feed=[0.45, 0.55],  # mole fraction n-Butane = 0.45</span>
<span class="go">        RR=1.,                # reflux ratio [L/D]</span>
<span class="go">        D=400.,               # distillate flow rate [kmol/h]</span>
<span class="go">        N=3,                  # number of equilibrium contacts</span>
<span class="go">        feed_stage=2,         # stage at which feed goes in</span>
<span class="go">)</span>
</pre></div>
</div>
<p>Currently, the input design flow rates must be
specified in kmol/h and the pressure must be specified in Pa.
The method called in this process is
<code class="xref py py-meth docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.__init__()</span></code>
(see <a class="reference internal" href="#amund-code"><span class="std std-ref">Class Method Reference</span></a>).</p>
</div>
<div class="section" id="step-2-make-initial-guess">
<span id="step2"></span><h3><span class="section-number">4.3.2. </span>Step 2, Make Initial Guess<a class="headerlink" href="#step-2-make-initial-guess" title="Permalink to this headline">¶</a></h3>
<p>Before beginning the solution procedure,
we need to have an initial guess for the liquid flow rates,
vapor flow rates, and temperatures on each stage <span class="math notranslate nohighlight">\(j\)</span>.
That is, we need to generate initial guesses for
<span class="math notranslate nohighlight">\(L_j\)</span>, <span class="math notranslate nohighlight">\(V_j\)</span>, and <span class="math notranslate nohighlight">\(T_j\)</span>.</p>
<p>First we calculate the feed temperature
(which is a saturated liquid) using
a bubble point calculation (see <a class="reference internal" href="bubble.html#bubble"><span class="std std-ref">Bubble Point</span></a>).</p>
<div class="highlight-python: notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; model.calculate_T_feed()
</pre></div>
</div>
<p>We set the temperatures <span class="math notranslate nohighlight">\(T_j\)</span>
to be the same as the feed temperature.
This step is performed automatically when the model
is initialized with input parameters.
We can check to see the feed temperature calculated
for our model by the following</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">T_feed</span>
<span class="go">306.37018410667076</span>
</pre></div>
</div>
<p>Then, we generate the initial guesses
for these values by assuming constant molal overflow (the Lewis method).
Computationally, we can do this using the following</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">generate_initial_guess</span><span class="p">()</span>
</pre></div>
</div>
<p>We can then check the arrays of liquid flow rates (<span class="math notranslate nohighlight">\(L\)</span>)
and vapor flow rates (<span class="math notranslate nohighlight">\(V\)</span>) obtained by the calculations as below</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">L</span>
<span class="go">array([ 400.,  400., 1400.,  600.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">V</span>
<span class="go">array([   0., 800., 800., 800.])</span>
</pre></div>
</div>
<p>or, looking at the liquid flow rates by stage more specifically,
.. code-block:: python</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">stage</span><span class="p">,</span> <span class="n">L_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L_j&#39;</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">L_j</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">L_j 0 400.0</span>
<span class="go">L_j 1 400.0</span>
<span class="go">L_j 2 1400.0</span>
<span class="go">L_j 3 600.0</span>
</pre></div>
</div>
<p>Here, we see that the liquid flow rates in the enriching
section are <span class="math notranslate nohighlight">\((L/D)\times D=1\times 400=400=L\)</span>.
Since the feed stage is stage 2, we notice that
the liquid leaving this stage is equal to <span class="math notranslate nohighlight">\(\overline{L}=L + F=400 + 1000\)</span>.
Finally, we notice that the liquid leaving the bottom stage,
the partial reboiler, is the same as the bottoms
flow rate that would be calculated from an overall balance,
<span class="math notranslate nohighlight">\(B = F - D = 1000 - 400 = 600\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">stage</span><span class="p">,</span> <span class="n">V_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">V</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;V_j&#39;</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">V_j</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">V_j 0 0.0</span>
<span class="go">V_j 1 800.0</span>
<span class="go">V_j 2 800.0</span>
<span class="go">V_j 3 800.0</span>
</pre></div>
</div>
<p>We note that there is no vapor leaving stage 0 because the
column is equipped with a total condensor.
We note that <code class="code docutils literal notranslate"><span class="pre">V[1]</span> <span class="pre">=</span> <span class="pre">model.RR*model.D</span> <span class="pre">+</span> <span class="pre">model.D</span></code>,
which arises from the mass balance at the top of the column.
Similarly, we also realize that
<code class="code docutils literal notranslate"><span class="pre">V[3]</span> <span class="pre">=</span> <span class="pre">model.L[2]</span> <span class="pre">-</span> <span class="pre">model.B</span></code>.</p>
</div>
<div class="section" id="step-3-update-k-values">
<h3><span class="section-number">4.3.3. </span>Step 3, Update <span class="math notranslate nohighlight">\(K\)</span>-values<a class="headerlink" href="#step-3-update-k-values" title="Permalink to this headline">¶</a></h3>
<p>In Step 3, we calculate <span class="math notranslate nohighlight">\(K_{i,j}\)</span>, the
<span class="math notranslate nohighlight">\(K\)</span>-value for each component <span class="math notranslate nohighlight">\(i\)</span> on stage <span class="math notranslate nohighlight">\(j\)</span>.
We can do this now for our model by the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">update_K_values</span><span class="p">()</span>
</pre></div>
</div>
<p>We can think of this step as doing something similar to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">P_feed</span><span class="p">)</span>
</pre></div>
</div>
<p>where the <code class="code docutils literal notranslate"><span class="pre">K_func</span></code> function returns the <span class="math notranslate nohighlight">\(K\)</span>-value for component
<span class="math notranslate nohighlight">\(i\)</span> on stage <span class="math notranslate nohighlight">\(j\)</span>.
The <code class="code docutils literal notranslate"><span class="pre">for</span></code> loops iteratively store the <span class="math notranslate nohighlight">\(K\)</span>-values in each component of the amtrix.</p>
<p>In our example, we can checkout our new <span class="math notranslate nohighlight">\(K\)</span>-values as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pprint</span>  <span class="c1"># for pretty printing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
<span class="go">{&#39;n-Butane&#39;: array([1.61320297, 1.61320297, 1.61320297, 1.61320297]),</span>
<span class="go"> &#39;n-Pentane&#39;: array([0.49828848, 0.49828848, 0.49828848, 0.49828848])}</span>
</pre></div>
</div>
<p>As expected, the values for butane are higher for the light component, butane.
The values are also the same for all stages because the temperature
of all stages are currently fixed at the feed temperature.</p>
<p>Behind the scenes, we then store the current stage temperatures
in an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">T_old</span></code> which
we will need later in <a class="reference internal" href="#step-6"><span class="std std-ref">Step 6, T_j Convergence Check</span></a> to determine whether the temperature
has converged.</p>
<p>The code for this step is depicted in
<a class="reference internal" href="#distillation.amundson_1958.main.Model.update_K_values" title="distillation.amundson_1958.main.Model.update_K_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.update_K_values()</span></code></a>.</p>
</div>
<div class="section" id="step-4-solve-component-mass-balances">
<span id="stage-4"></span><h3><span class="section-number">4.3.4. </span>Step 4, Solve Component Mass Balances<a class="headerlink" href="#step-4-solve-component-mass-balances" title="Permalink to this headline">¶</a></h3>
<p>The two stages in which tridiagonal matrices are used
for computational efficiency are <a class="reference internal" href="#stage-4"><span class="std std-ref">Step 4, Solve Component Mass Balances</span></a> and <a class="reference internal" href="#step-7"><span class="std std-ref">Step 7, Solve Energy Balances</span></a>,
which are depicted in colored blue boxes.</p>
<p>In this step, the matrices are tridiagonal for the complete
mass balances for <em>each</em> component (as opposed to all components together).
The variables that are calculated are <span class="math notranslate nohighlight">\(l_{ij}\)</span> for each component <span class="math notranslate nohighlight">\(i\)</span>
and each stage <span class="math notranslate nohighlight">\(j\)</span>.
This new variable is introduced where <span class="math notranslate nohighlight">\(l_{ij}=x_iL_j\)</span>,
and can be interpreted as a <em>component</em> flow rate.
By formulating the mass balance equations into function of <span class="math notranslate nohighlight">\(l_{ij}\)</span>
the system of equations can be converted in to a tridiagonal matrix.</p>
<p>For a general stage <span class="math notranslate nohighlight">\(j\)</span>,
the mass balance on component <span class="math notranslate nohighlight">\(i\)</span> is</p>
<div class="math notranslate nohighlight">
\[V_jy_{i,j} + L_j x_{i,j} - V_{j+1}y_{i,j+1} - L_{j-1}x_{i,j-1} = F_jz_{i,j}\]</div>
<p>Using the following relationships</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    y_{i,j} &amp;= K_jx_{i,j} \\
    y_{i,j+1} &amp;= K_{j+1}x_{i,j+1} \\
\end{align}\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
    x_{i,j} &amp;= \frac{l_{i,j}}{L_j}\\
    x_{i,j-1} &amp;= \frac{l_{i,j-1}}{L_{j-1}}\\
\end{align}\end{split}\]</div>
<p>we obtain</p>
<div class="math notranslate nohighlight">
\[-l_{i,j-1} + \left(1 + \frac{V_jK_j}{L_j}\right)l_{i,j} - \left(\frac{V_{j+1}K_{j+1}}{L_{j+1}}\right)l_{i,j+1}=F_jz_{i,j}\]</div>
<p>Computationally, we can perform this step
using our model by the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">model</span><span class="o">.</span><span class="n">solve_component_mass_bal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>First, the tridiagonal matrix is generated.
Then, the efficient approach described in <a class="reference internal" href="#tri-matrix"><span class="std std-ref">Mathematical Trick</span></a> is used.
to solve the equations.</p>
<p>We can see the results of the calculation by probing
the model attributes as follows</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pprint</span> <span class="c1"># pretty printing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">l</span><span class="p">)</span>
<span class="go">{&#39;n-Butane&#39;: array([288.88918652, 179.07801532, 507.65007098, 161.11081348]),</span>
<span class="go"> &#39;n-Pentane&#39;: array([ 74.88288594, 150.28018773, 790.77762525, 475.11711406])}</span>
</pre></div>
</div>
<p>Since <span class="math notranslate nohighlight">\(\sum_i l_{i,j} = L_j\)</span>, it is worthwhile to compare
our calculations to what was calculated for <span class="math notranslate nohighlight">\(L_j\)</span> with the
Lewis method (i.e. assuming Constant Molal Overflow)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">stage</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">stages</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">stage</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">L</span><span class="p">[</span><span class="n">stage</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;n-Butane&#39;</span><span class="p">][</span><span class="n">stage</span><span class="p">]</span><span class="o">+</span><span class="n">model</span><span class="o">.</span><span class="n">l</span><span class="p">[</span><span class="s1">&#39;n-Pentane&#39;</span><span class="p">][</span><span class="n">stage</span><span class="p">])</span>
<span class="gp">...</span>
<span class="go">0 400.0 363.7720724598715</span>
<span class="go">1 400.0 329.3582030449366</span>
<span class="go">2 1400.0 1298.4276962288486</span>
<span class="go">3 600.0 636.2279275401286</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>From this analysis, we realize that our initial guess for the liquid and vapor flow rates was not that bad.</p>
</div>
<div class="section" id="step-5">
<span id="id2"></span><h3><span class="section-number">4.3.5. </span>Step 5<a class="headerlink" href="#step-5" title="Permalink to this headline">¶</a></h3>
<p>In <a class="reference internal" href="#step2"><span class="std std-ref">Step 2, Make Initial Guess</span></a>, we performed a <a class="reference internal" href="bubble.html#bubble"><span class="std std-ref">Bubble Point</span></a> calculation
to determine the temperature of the feed.
We do the same thing here, except we do it multiple times
(i.e., for each stage).
However, we have not calculated the liquid phase mole fractions
explicitly yet.
We can use the liquid component mass balances calculated in <a class="reference internal" href="#stage-4"><span class="std std-ref">Step 4, Solve Component Mass Balances</span></a>
to calculate the mole fractions as</p>
<div class="math notranslate nohighlight">
\[x_{ij} = \frac{l_{ij}}{\sum_k l_{kj}}\]</div>
<p>and then perform the <a class="reference internal" href="bubble.html#bubble"><span class="std std-ref">Bubble Point</span></a> calculations
with these mole fractions.</p>
<p>Computationally, we can perform this step with our
model using the following</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([306.37018411, 306.37018411, 306.37018411, 306.37018411])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">update_T_values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([295.34137166 302.94861315 308.72858323 314.97039634])</span>
</pre></div>
</div>
<p>And we can see how the temperatures change from the initial guess (the feed temperature)
to the results of the first calculation.</p>
</div>
<div class="section" id="step-6-t-j-convergence-check">
<span id="step-6"></span><h3><span class="section-number">4.3.6. </span>Step 6, <span class="math notranslate nohighlight">\(T_j\)</span> Convergence Check<a class="headerlink" href="#step-6-t-j-convergence-check" title="Permalink to this headline">¶</a></h3>
<p>In this step, we determine whether the temperatures on all stages <span class="math notranslate nohighlight">\(j\)</span>,
<span class="math notranslate nohighlight">\(T_j\)</span>, have converged.
Mathematically, we require the following</p>
<div class="math notranslate nohighlight">
\[\sqrt{\left(T_{j,\mathrm{new}} - T_{j,\mathrm{old}}\right)^2} &lt; \epsilon\]</div>
<p>The temperature tolerance <span class="math notranslate nohighlight">\(\epsilon\)</span>
is attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.temperature_tol</span></code>;
It is currently set to 0.01.</p>
<p>We can see from <a class="reference internal" href="#step-5"><span class="std std-ref">Step 5</span></a> that the temperature
has clearly changed by more than 0.01~K between
the first iteration. When we perform this step,
we find that the temperature has not converged.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">T_is_converged</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Following the algorithmic diagram,
we go back to Step 3 and perform a few more iterations.</p>
<p>Its convenient to perform these iterations with a while loop, as follows</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">T_is_converged</span><span class="p">():</span>
<span class="o">...</span>     <span class="n">model</span><span class="o">.</span><span class="n">update_K_values</span><span class="p">()</span>
<span class="o">...</span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
<span class="o">...</span>         <span class="n">model</span><span class="o">.</span><span class="n">solve_component_mass_bal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="o">...</span>     <span class="n">model</span><span class="o">.</span><span class="n">update_T_values</span><span class="p">()</span>
<span class="o">...</span>     <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="o">...</span>
<span class="p">[</span><span class="mf">295.50131711</span> <span class="mf">303.41982848</span> <span class="mf">309.35773209</span> <span class="mf">315.96224522</span><span class="p">]</span>
<span class="p">[</span><span class="mf">295.6166139</span>  <span class="mf">303.62102821</span> <span class="mf">309.52271272</span> <span class="mf">316.15309479</span><span class="p">]</span>
<span class="p">[</span><span class="mf">295.65094925</span> <span class="mf">303.67756389</span> <span class="mf">309.56508571</span> <span class="mf">316.19923696</span><span class="p">]</span>
<span class="p">[</span><span class="mf">295.66006297</span> <span class="mf">303.69238402</span> <span class="mf">309.57598554</span> <span class="mf">316.21097278</span><span class="p">]</span>
<span class="p">[</span><span class="mf">295.66242518</span> <span class="mf">303.69621481</span> <span class="mf">309.57879188</span> <span class="mf">316.21398756</span><span class="p">]</span>
</pre></div>
</div>
<p>The temperature is converged after 5 more iterations,
as we can see from the output above.
Since the temperature has converged,
we can now proceed to the next step.</p>
</div>
<div class="section" id="step-7-solve-energy-balances">
<span id="step-7"></span><h3><span class="section-number">4.3.7. </span>Step 7, Solve Energy Balances<a class="headerlink" href="#step-7-solve-energy-balances" title="Permalink to this headline">¶</a></h3>
<p>In Step 7, we solve the energy balances.
Here, all the balances can again be combined into one banded matrix.</p>
<p>For a general stage <span class="math notranslate nohighlight">\(j\)</span>,
the energy balance is</p>
<div class="math notranslate nohighlight">
\[L_j h_j + V_jH_j = V_{j+1}H_{j+1} + L_{j-1}h_{j-1} + F_j h_{j,\mathrm{feed}} + Q_j\]</div>
<p>The liquid flow rates can be substituted in using the following relationship</p>
<div class="math notranslate nohighlight">
\[L_k = V_{k+1} - D + \sum_{m=0}^k F_m\]</div>
<p>So that the system of equations only becomes functions of <span class="math notranslate nohighlight">\(V_j\)</span> and <span class="math notranslate nohighlight">\(V_{j+1}\)</span>.</p>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Finish description of energy balance</p>
</div>
<p>A helper function for creation and solution of these
matrices is provided in the model.
In other words, the energy balances can be solved
by the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">L</span>
<span class="go">array([ 400.,  400., 1400.,  600.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">V</span>
<span class="go">array([  0., 800., 800., 800.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">solve_energy_balances</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">L</span>
<span class="go">array([ 400.        ,  312.3605968 , 1300.10206406,  600.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">V</span>
<span class="go">array([  0.        , 730.64500782, 712.3605968 , 700.10206406])</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>Where we have added extra steps so that we can check the
values of <code class="code docutils literal notranslate"><span class="pre">model.L</span></code> and <code class="code docutils literal notranslate"><span class="pre">model.V</span></code> before
and after solving the energy balances.</p>
</div>
<div class="section" id="step-8-v-j-l-j-convergence-check">
<h3><span class="section-number">4.3.8. </span>Step 8, <span class="math notranslate nohighlight">\(V_j\)</span>, <span class="math notranslate nohighlight">\(L_j\)</span> Convergence Check<a class="headerlink" href="#step-8-v-j-l-j-convergence-check" title="Permalink to this headline">¶</a></h3>
<p>In this step, we determine if the simulation has converged.
If the following holds true for all stages <span class="math notranslate nohighlight">\(j\)</span></p>
<div class="math notranslate nohighlight">
\[\sqrt{\left(\frac{X_{j,\mathrm{new}} - X_{j,\mathrm{old}}}{X_{j,\mathrm{new}}}\right)^2} &lt; \epsilon\]</div>
<p>for each variable <span class="math notranslate nohighlight">\(X=V\)</span> and <span class="math notranslate nohighlight">\(X=L\)</span>.
The flow rate tolerance, <span class="math notranslate nohighlight">\(\epsilon\)</span>,
is found in the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.flow_rate_tol</span></code>.
The code for this step is found in <a class="reference internal" href="#distillation.amundson_1958.main.Model.flow_rates_converged" title="distillation.amundson_1958.main.Model.flow_rates_converged"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.flow_rates_converged()</span></code></a></p>
<p>Obviously, our flow rates have not converged after just one iteration,
as we have seen that several values have changed by <span class="math notranslate nohighlight">\(\\approx 100\)</span> kmol/h.
We will need to come up with a looping algorithm to
get the simulation to converge, as described in the next section.</p>
</div>
</div>
<div class="section" id="putting-it-all-together">
<h2><span class="section-number">4.4. </span>Putting it all together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this headline">¶</a></h2>
<p>So far, we can combine our code from the tutorial into
the following</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">distillation.amundson_1958</span> <span class="kn">import</span> <span class="n">Model</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span>
<span class="go">        components=[&#39;n-Butane&#39;, &#39;n-Pentane&#39;],</span>
<span class="go">        F=1000.,              # feed flow rate [kmol/h]</span>
<span class="go">        P=101325.*2,          # pressure (constant) [Pa]</span>
<span class="go">        z_feed=[0.45, 0.55],  # mole fraction n-Butane = 0.45</span>
<span class="go">        RR=1.,                # reflux ratio [L/D]</span>
<span class="go">        D=400.,               # distillate flow rate [kmol/h]</span>
<span class="go">        N=3,                  # number of equilibrium contacts</span>
<span class="go">        feed_stage=2,         # stage at which feed goes in</span>
<span class="go">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">generate_initial_guess</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">T_is_converged</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">model</span><span class="o">.</span><span class="n">update_K_values</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">model</span><span class="o">.</span><span class="n">solve_component_mass_bal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">model</span><span class="o">.</span><span class="n">update_T_values</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">solve_energy_balances</span><span class="p">()</span>
</pre></div>
</div>
<p>But we need to figure out how to do the last iteration to automatically try to converge.
It turns out, we can do this with a nested <code class="code docutils literal notranslate"><span class="pre">while</span></code> loop,
as shown below</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">flow_rates_converged</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">model</span><span class="o">.</span><span class="n">solve_component_mass_bal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">model</span><span class="o">.</span><span class="n">update_T_values</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">while</span> <span class="ow">not</span> <span class="n">model</span><span class="o">.</span><span class="n">T_is_converged</span><span class="p">():</span>
<span class="gp">... </span>        <span class="n">model</span><span class="o">.</span><span class="n">update_K_values</span><span class="p">()</span>
<span class="gp">... </span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">model</span><span class="o">.</span><span class="n">solve_component_mass_bal</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">model</span><span class="o">.</span><span class="n">update_T_values</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">model</span><span class="o">.</span><span class="n">solve_energy_balances</span><span class="p">()</span>
<span class="gp">...</span>
</pre></div>
</div>
<p>This is what happens when the user invokes <code class="code docutils literal notranslate"><span class="pre">model.run()</span></code>
For our example, it turns out that it takes about 4 loops
through the step 4-8 loop, and then we will be converged.
The final results for the flow rates can be calculated as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">L</span>
<span class="go">array([ 400.        ,  353.80944637, 1340.92773179,  600.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">V</span>
<span class="go">array([  0.        , 733.53885641, 753.80944637, 740.92773179])</span>
</pre></div>
</div>
<p>which is still quite similar to what we calculated by the Lewis method.
We can also take a look at the stage temperatures and mole fractions
as below</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">T</span>
<span class="go">array([295.60405689, 303.58875055, 309.37291267, 315.8254746 ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">x_ij_expr</span><span class="p">(</span><span class="s1">&#39;n-Butane&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">stages</span><span class="p">)</span>
<span class="go">[0.7648435805973592, 0.5587863474554224, 0.38180690272177853, 0.24010427960176078]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">y_ij_expr</span><span class="p">(</span><span class="s1">&#39;n-Butane&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">stages</span><span class="p">)</span>
<span class="go">[0.902879383384724, 0.8342045394354831, 0.6681268674620511, 0.4965317369291433]</span>
</pre></div>
</div>
<p>As expected, the distillate is greatly enriched in the light component (n-Butane).</p>
</div>
<div class="section" id="class-method-reference">
<span id="amund-code"></span><h2><span class="section-number">4.5. </span>Class Method Reference<a class="headerlink" href="#class-method-reference" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="distillation.amundson_1958.main.Model">
<em class="property">class </em><code class="sig-prename descclassname">distillation.amundson_1958.main.</code><code class="sig-name descname">Model</code><span class="sig-paren">(</span><em class="sig-param">components: list = None</em>, <em class="sig-param">F: float = 0.0</em>, <em class="sig-param">P: float = 101325.0</em>, <em class="sig-param">z_feed: list = None</em>, <em class="sig-param">RR: float = 1</em>, <em class="sig-param">D: float = 0</em>, <em class="sig-param">N: int = 1</em>, <em class="sig-param">feed_stage: int = 0</em>, <em class="sig-param">T_feed_guess: float = 300.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="distillation.amundson_1958.main.Model.H_j_rule">
<code class="sig-name descname">H_j_rule</code><span class="sig-paren">(</span><em class="sig-param">stage</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.H_j_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.H_j_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Enthalpy of vapor on stage <em>j</em>.
Calculated for ideal mixture</p>
<div class="math notranslate nohighlight">
\[H_j = \sum_i y_{ij}H^*_i(T_j)\]</div>
<p>where the asterisk indicates the pure component enthalpy</p>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>convert y mole fractions to dynamic expression</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(H_j\)</span> [J/kmol]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.H_pure_rule">
<code class="sig-name descname">H_pure_rule</code><span class="sig-paren">(</span><em class="sig-param">c</em>, <em class="sig-param">T</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.H_pure_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.H_pure_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Rule for vapor enthalpy of pure component</p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.Q_condenser_rule">
<code class="sig-name descname">Q_condenser_rule</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.Q_condenser_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.Q_condenser_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Condenser requirement can be determined from balances around total condenser</p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.T_is_converged">
<code class="sig-name descname">T_is_converged</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.T_is_converged"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.T_is_converged" title="Permalink to this definition">¶</a></dt>
<dd><p>In this step, we determine whether the temperatures on all stages <span class="math notranslate nohighlight">\(j\)</span>,
<span class="math notranslate nohighlight">\(T_j\)</span>, have converged.
Mathematically, we require the following</p>
<div class="math notranslate nohighlight">
\[\sqrt{\left(T_{j,\mathrm{new}} - T_{j,\mathrm{old}}\right)^2} &lt; \epsilon\]</div>
<p>The temperature tolerance <span class="math notranslate nohighlight">\(\epsilon\)</span>
is attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.temperature_tol</span></code>;
It is currently set to 0.01.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if T is converged, else False</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.add_parameters">
<code class="sig-name descname">add_parameters</code><span class="sig-paren">(</span><em class="sig-param">verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.add_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.add_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Add thermodynamic parameters for calculation</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>K values from DePriester charts
CpL from Perrys
CpV assumes ideal gas
dH_vap from NIST Webbook</p>
</div>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.calculate_T_feed">
<code class="sig-name descname">calculate_T_feed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.calculate_T_feed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.calculate_T_feed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.flow_rates_converged">
<code class="sig-name descname">flow_rates_converged</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.flow_rates_converged"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.flow_rates_converged" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if flow rates are converged</p>
<p>Use the mathematical criterion in <a class="reference internal" href="#distillation.amundson_1958.main.Model.is_below_relative_error" title="distillation.amundson_1958.main.Model.is_below_relative_error"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Model.is_below_relative_error()</span></code></a></p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.h_feed_rule">
<code class="sig-name descname">h_feed_rule</code><span class="sig-paren">(</span><em class="sig-param">stage</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.h_feed_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.h_feed_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Enthalpy of liquid in feed mixture
Calculated for ideal mixture</p>
<div class="math notranslate nohighlight">
\[h = \sum_i x_{ij}h^*_i(T_j)\]</div>
<p>where the asterisk indicates the pure component enthalpy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(h\)</span> [J/kmol]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.h_j_rule">
<code class="sig-name descname">h_j_rule</code><span class="sig-paren">(</span><em class="sig-param">stage</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.h_j_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.h_j_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Enthalpy of liquid on stage <em>j</em>.
Calculated for ideal mixture</p>
<div class="math notranslate nohighlight">
\[h_j = \sum_i x_{ij}h^*_i(T_j)\]</div>
<p>where the asterisk indicates the pure component enthalpy</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(h_j\)</span> [J/kmol]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.h_pure_rule">
<code class="sig-name descname">h_pure_rule</code><span class="sig-paren">(</span><em class="sig-param">c</em>, <em class="sig-param">T</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.h_pure_rule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.h_pure_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>rule for liquid enthalpy of pure component</p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.initialize_flow_rates">
<code class="sig-name descname">initialize_flow_rates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.initialize_flow_rates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.initialize_flow_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Before beginning the solution procedure,
we need to have an initial guess for the liquid flow rates,
vapor flow rates, and temperatures on each stage <span class="math notranslate nohighlight">\(j\)</span>.
That is, we need to generate initial guesses for
<span class="math notranslate nohighlight">\(L_j\)</span>, <span class="math notranslate nohighlight">\(V_j\)</span>, and <span class="math notranslate nohighlight">\(T_j\)</span>.</p>
<p>First we calculate the feed temperature
(which is a saturated liquid) using
a bubble point calculation (see <a class="reference internal" href="bubble.html#bubble"><span class="std std-ref">Bubble Point</span></a>).</p>
<div class="highlight-python: notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; model.calculate_T_feed()
</pre></div>
</div>
<p>We set the temperatures <span class="math notranslate nohighlight">\(T_j\)</span>
to be the same as the feed temperature.
This step is performed automatically when the model
is initialized with input parameters.
We can check to see the feed temperature calculated
for our model by the following</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">T_feed</span>
<span class="go">306.37018410667076</span>
</pre></div>
</div>
<p>Then, we generate the initial guesses
for these values by assuming constant molal overflow (the Lewis method).
Computationally, we can do this using the following</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">generate_initial_guess</span><span class="p">()</span>
</pre></div>
</div>
<p>We can then check the arrays of liquid flow rates (<span class="math notranslate nohighlight">\(L\)</span>)
and vapor flow rates (<span class="math notranslate nohighlight">\(V\)</span>) obtained by the calculations as below</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">L</span>
<span class="go">array([ 400.,  400., 1400.,  600.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">V</span>
<span class="go">array([   0., 800., 800., 800.])</span>
</pre></div>
</div>
<p>or, looking at the liquid flow rates by stage more specifically,
.. code-block:: python</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">stage</span><span class="p">,</span> <span class="n">L_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L_j&#39;</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">L_j</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">L_j 0 400.0</span>
<span class="go">L_j 1 400.0</span>
<span class="go">L_j 2 1400.0</span>
<span class="go">L_j 3 600.0</span>
</pre></div>
</div>
<p>Here, we see that the liquid flow rates in the enriching
section are <span class="math notranslate nohighlight">\((L/D)\times D=1\times 400=400=L\)</span>.
Since the feed stage is stage 2, we notice that
the liquid leaving this stage is equal to <span class="math notranslate nohighlight">\(\overline{L}=L + F=400 + 1000\)</span>.
Finally, we notice that the liquid leaving the bottom stage,
the partial reboiler, is the same as the bottoms
flow rate that would be calculated from an overall balance,
<span class="math notranslate nohighlight">\(B = F - D = 1000 - 400 = 600\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">stage</span><span class="p">,</span> <span class="n">V_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">V</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;V_j&#39;</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">V_j</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">V_j 0 0.0</span>
<span class="go">V_j 1 800.0</span>
<span class="go">V_j 2 800.0</span>
<span class="go">V_j 3 800.0</span>
</pre></div>
</div>
<p>We note that there is no vapor leaving stage 0 because the
column is equipped with a total condensor.
We note that <code class="code docutils literal notranslate"><span class="pre">V[1]</span> <span class="pre">=</span> <span class="pre">model.RR*model.D</span> <span class="pre">+</span> <span class="pre">model.D</span></code>,
which arises from the mass balance at the top of the column.
Similarly, we also realize that
<code class="code docutils literal notranslate"><span class="pre">V[3]</span> <span class="pre">=</span> <span class="pre">model.L[2]</span> <span class="pre">-</span> <span class="pre">model.B</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.is_below_relative_error">
<code class="sig-name descname">is_below_relative_error</code><span class="sig-paren">(</span><em class="sig-param">new</em>, <em class="sig-param">old</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.is_below_relative_error"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.is_below_relative_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine relative error between two vectors</p>
<div class="math notranslate nohighlight">
\[\sqrt{\left(\frac{X_{\mathrm{new}} - X_{\mathrm{old}}}{X_{\mathrm{new}}}\right)^2} &lt; \epsilon\]</div>
<p>The flow rate tolerance, <span class="math notranslate nohighlight">\(\epsilon\)</span>,
is found in the attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.flow_rate_tol</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>new</strong> – </p></li>
<li><p><strong>old</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.solve_component_mass_bal">
<code class="sig-name descname">solve_component_mass_bal</code><span class="sig-paren">(</span><em class="sig-param">component</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.solve_component_mass_bal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.solve_component_mass_bal" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve component mass balances</p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.solve_energy_balances">
<code class="sig-name descname">solve_energy_balances</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.solve_energy_balances"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.solve_energy_balances" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve energy balances</p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.update_K_values">
<code class="sig-name descname">update_K_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.update_K_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.update_K_values" title="Permalink to this definition">¶</a></dt>
<dd><p>In Step 3, we calculate <span class="math notranslate nohighlight">\(K_{i,j}\)</span>, the
<span class="math notranslate nohighlight">\(K\)</span>-value for each component <span class="math notranslate nohighlight">\(i\)</span> on stage <span class="math notranslate nohighlight">\(j\)</span>.
We can do this now for our model by the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">update_K_values</span><span class="p">()</span>
</pre></div>
</div>
<p>We can think of this step as doing something similar to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">model</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">K_func</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">model</span><span class="o">.</span><span class="n">P_feed</span><span class="p">)</span>
</pre></div>
</div>
<p>where the <code class="code docutils literal notranslate"><span class="pre">K_func</span></code> function returns the <span class="math notranslate nohighlight">\(K\)</span>-value for component
<span class="math notranslate nohighlight">\(i\)</span> on stage <span class="math notranslate nohighlight">\(j\)</span>.
The <code class="code docutils literal notranslate"><span class="pre">for</span></code> loops iteratively store the <span class="math notranslate nohighlight">\(K\)</span>-values in each component of the amtrix.</p>
<p>In our example, we can checkout our new <span class="math notranslate nohighlight">\(K\)</span>-values as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pprint</span>  <span class="c1"># for pretty printing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
<span class="go">{&#39;n-Butane&#39;: array([1.61320297, 1.61320297, 1.61320297, 1.61320297]),</span>
<span class="go"> &#39;n-Pentane&#39;: array([0.49828848, 0.49828848, 0.49828848, 0.49828848])}</span>
</pre></div>
</div>
<p>As expected, the values for butane are higher for the light component, butane.
The values are also the same for all stages because the temperature
of all stages are currently fixed at the feed temperature.</p>
<p>Behind the scenes, we then store the current stage temperatures
in an attribute <code class="xref py py-attr docutils literal notranslate"><span class="pre">T_old</span></code> which
we will need later in <a class="reference internal" href="#step-6"><span class="std std-ref">Step 6, T_j Convergence Check</span></a> to determine whether the temperature
has converged.</p>
<p>The code for this step is depicted in
<a class="reference internal" href="#distillation.amundson_1958.main.Model.update_K_values" title="distillation.amundson_1958.main.Model.update_K_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distillation.amundson_1958.main.Model.update_K_values()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.update_T_values">
<code class="sig-name descname">update_T_values</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.update_T_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.update_T_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Update temperatures in all stages
by performing bubble point calculation</p>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>vectorize with matrix multiplication</p>
</div>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.x_ij_expr">
<code class="sig-name descname">x_ij_expr</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.x_ij_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.x_ij_expr" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – component name</p></li>
<li><p><strong>j</strong> – stage number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>mole fraction on stage</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="distillation.amundson_1958.main.Model.y_ij_expr">
<code class="sig-name descname">y_ij_expr</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">j</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/distillation/amundson_1958/main.html#Model.y_ij_expr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#distillation.amundson_1958.main.Model.y_ij_expr" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – component name</p></li>
<li><p><strong>j</strong> – stage number</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>gas-phase mole fraction on stage</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="bubble.html" class="btn btn-neutral float-right" title="5. Bubble Point" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="balances.html" class="btn btn-neutral float-left" title="3. Material and Energy Balances" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robert F. DeJaco

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>